/* Autogenerated - do not edit */

#include <stdlib.h>
#include <string.h>
#include <toolbox.h>
#include <test_event.h>
#include "stdio.h"

typedef struct test_function_state {
	struct {
		int testval;
		void *pointer;
	} in;

	struct {
	} stack;

	/*
	 *	struct {
	 *		int errorcode;
	 *		int xid;
	 *		struct __sbuf junk;
	 *	} out;
	 */
	test_function_out out;

	int state;
	int loopdetect;
	int forkcounter;
	void *ret;
	void (*retfree)(void *);

	EVENTCB_function *cbfunc;
	void *cbarg;
} test_function_state;

static void
free_function_state(test_function_state *state)
{
	if (state->ret) {
		if (state->retfree)
			state->retfree(state->ret);
		free(state->ret);
		state->ret = NULL;
	}
	free_function_out(&state->out);
}

void
free_function_out(void *arg)
{
	/* ((test_function_out *)arg)->xid */
	/* ((test_function_out *)arg)->junk */
}

static int go_function(test_function_state *);
/*
 * Function: CODE
 * RET Type: none
 * Wait ptr: 0
 * Rtry ptr: 0
 */
static int
act_function_state_0(test_function_state *state)
{
	int test_function_return = TBEVENT_BLOCKDONE;
#line 17 "/Users/maxwell/code/gw/event/test/test.event"
	{
		log_debug("function(%d, 0x%p)",
				(&(state->in))->testval, (&(state->in))->pointer);
		(&(state->out))->xid = 999;
		(&(state->out))->junk._base = NULL;
		(&(state->out))->junk._size = 333;
	}
#line 76 "/Users/maxwell/code/gw/event/test/generated/event_function.c"
	return test_function_return;
}

/*
 * Function: CODE
 * RET Type: none
 * Wait ptr: 0
 * Rtry ptr: 0
 */
static int
act_function_state_1(test_function_state *state)
{
	int test_function_return = TBEVENT_BLOCKDONE;
#line 25 "/Users/maxwell/code/gw/event/test/test.event"
	{
		(state->out.errorcode) = TBOX_API_INVALID;
		{ state->out.errorcode = TBOX_API_INVALID; test_function_return = TBEVENT_FINISH; goto test_function_out; }
	}
#line 95 "/Users/maxwell/code/gw/event/test/generated/event_function.c"
test_function_out:
	return test_function_return;
}

/*
 * Function: EMPTY
 * RET Type: none
 * Wait ptr: 0
 * Rtry ptr: 0
 */
static int
fin_function_state_2(test_function_state *state)
{
	return TBEVENT_BLOCKDONE;
}

static int
go_function(test_function_state *state)
{
	int ret = TBEVENT_SUCCESS;

	if (state->loopdetect)
		return TBEVENT_SUCCESS;
	else
		state->loopdetect++;

top:
	switch (state->state) {
		case 0:
			ret = act_function_state_0(state);
			break;
		case 1:
			ret = act_function_state_1(state);
			break;
		case 2:
			ret = fin_function_state_2(state);
			break;
		case 3:
			ret = TBEVENT_FINISH;
			break;
		default:
			log_warnx("go_function: invalid state %d", state->state);
			ret = TBOX_API_INVALID;
			goto out;
	}
	if (ret == TBEVENT_BLOCKDONE || ret == TBEVENT_SUCCESS) {
		state->state++;
		if (state->state >= 0 && state->state <= 2)
			goto top;
	} else if (ret == TBEVENT_CALLBACK) {
		ret = TBEVENT_CALLBACK;
		goto out;
	} else if (ret == TBEVENT_FINISH) {
		if (state->state >= 0 && state->state < 2)
			state->state = 2;
		else
			state->state = 2 + 1;
		if (state->state >= 0 && state->state <= 2)
			goto top;
	} else if (ret != TBEVENT_SUCCESS) {
		if (state->state >= 0 && state->state < 2)
			state->state = 2;
		else
			state->state++;
		if (state->state >= 0 && state->state <= 2)
			goto top;
	}
	if (state->state >= 0 && state->state > 2) {
		if (state->cbfunc)
			ret = state->cbfunc(state->out.errorcode, state->cbarg,
					state->out.xid,
					state->out.junk);
		free_function_state(state);
		free(state);
		state = NULL;
	}
out:
	if (state)
		state->loopdetect--;
	if (ret == TBEVENT_SUCCESS || ret == TBEVENT_BLOCKDONE ||
			ret == TBEVENT_CALLBACK)
		return ret;
	else
		log_warnx("function: %s", tb_error(ret));
	return TBEVENT_BLOCKDONE;
}
int
function(EVENTCB_function *callback, void *arg,
		int testval,
		void *pointer)
{
	int ret = TBEVENT_SUCCESS;
	test_function_state *state;
	if ((state = calloc(1, sizeof(*state))) == NULL) {
		ret = TBOX_NOMEM;
		goto fail;
	}
	state->cbfunc = callback;
	state->cbarg = arg;
	state->in.testval = testval;
	state->in.pointer = pointer;
	ret = go_function(state);
	return ret;

fail:
	if (state) {
		free_function_state(state);
		free(state);
	}
	return ret;
}
