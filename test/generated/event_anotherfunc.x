/* Autogenerated - do not edit */

#include <stdlib.h>
#include <string.h>
#include <toolbox.h>
#include <test_event.h>

typedef struct test_anotherfunc_state {
	struct {
	} in;

	struct {
	} stack;

	/*
	 *	struct {
	 *		int errorcode;
	 *		int ignore;
	 *		int mytest;
	 *	} out;
	 */
	test_anotherfunc_out out;

	int state;
	int loopdetect;
	int forkcounter;
	void *ret;
	void (*retfree)(void *);

	EVENTCB_anotherfunc *cbfunc;
	void *cbarg;
} test_anotherfunc_state;

static void
free_anotherfunc_state(test_anotherfunc_state *state)
{
	if (state->ret) {
		if (state->retfree)
			state->retfree(state->ret);
		free(state->ret);
		state->ret = NULL;
	}
	free_anotherfunc_out(&state->out);
}

void
free_anotherfunc_out(void *arg)
{
	/* ((test_anotherfunc_out *)arg)->ignore */
	/* ((test_anotherfunc_out *)arg)->mytest */
}

static int go_anotherfunc(test_anotherfunc_state *);
/*
 * Function: SYNC
 * RET Type: none
 * Wait ptr: 0
 * Rtry ptr: 0
 */
static int
act_anotherfunc_state_0(test_anotherfunc_state *state)
{
	int test_anotherfunc_return = TBEVENT_BLOCKDONE;
#line 38 "/Users/maxwell/code/gw/event/test/test.event"
	{
		(&(state->out))->mytest = 111;
	}
#line 69 "/Users/maxwell/code/gw/event/test/generated/event_anotherfunc.c"
	return test_anotherfunc_return;
}

/*
 * Function: EMPTY
 * RET Type: none
 * Wait ptr: 0
 * Rtry ptr: 0
 */
static int
fin_anotherfunc_state_1(test_anotherfunc_state *state)
{
	return TBEVENT_BLOCKDONE;
}

static int
go_anotherfunc(test_anotherfunc_state *state)
{
	int ret = TBEVENT_SUCCESS;

	if (state->loopdetect)
		return TBEVENT_SUCCESS;
	else
		state->loopdetect++;

top:
	switch (state->state) {
		case 0:
			ret = act_anotherfunc_state_0(state);
			break;
		case 1:
			ret = fin_anotherfunc_state_1(state);
			break;
		case 2:
			ret = TBEVENT_FINISH;
			break;
		default:
			log_warnx("go_anotherfunc: invalid state %d", state->state);
			ret = TBOX_API_INVALID;
			goto out;
	}
	if (ret == TBEVENT_BLOCKDONE || ret == TBEVENT_SUCCESS) {
		state->state++;
		if (state->state >= 0 && state->state <= 1)
			goto top;
	} else if (ret == TBEVENT_CALLBACK) {
		ret = TBEVENT_CALLBACK;
		goto out;
	} else if (ret == TBEVENT_FINISH) {
		if (state->state >= 0 && state->state < 1)
			state->state = 1;
		else
			state->state = 1 + 1;
		if (state->state >= 0 && state->state <= 1)
			goto top;
	} else if (ret != TBEVENT_SUCCESS) {
		if (state->state >= 0 && state->state < 1)
			state->state = 1;
		else
			state->state++;
		if (state->state >= 0 && state->state <= 1)
			goto top;
	}
	if (state->state >= 0 && state->state > 1) {
		if (state->cbfunc)
			ret = state->cbfunc(state->out.errorcode, state->cbarg,
					state->out.ignore,
					state->out.mytest);
		free_anotherfunc_state(state);
		free(state);
		state = NULL;
	}
out:
	if (state)
		state->loopdetect--;
	if (ret == TBEVENT_SUCCESS || ret == TBEVENT_BLOCKDONE ||
			ret == TBEVENT_CALLBACK)
		return ret;
	else
		log_warnx("anotherfunc: %s", tb_error(ret));
	return TBEVENT_BLOCKDONE;
}
int
anotherfunc(EVENTCB_anotherfunc *callback, void *arg)
{
	int ret = TBEVENT_SUCCESS;
	test_anotherfunc_state *state;
	if ((state = calloc(1, sizeof(*state))) == NULL) {
		ret = TBOX_NOMEM;
		goto fail;
	}
	state->cbfunc = callback;
	state->cbarg = arg;
	ret = go_anotherfunc(state);
	return ret;

fail:
	if (state) {
		free_anotherfunc_state(state);
		free(state);
	}
	return ret;
}
